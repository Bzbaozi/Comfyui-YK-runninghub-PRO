import os
import requests
import time
import random
from PIL import Image
import numpy as np
import torch
from io import BytesIO
from concurrent.futures import ThreadPoolExecutor, as_completed
import base64

# 尝试导入 oss2（按需）
OSS_AVAILABLE = False
try:
    import oss2
    OSS_AVAILABLE = True
except ImportError:
    pass

class RunningHubRhartImageToImageBatch10:
    @classmethod
    def INPUT_TYPES(s):
        optional_inputs = {}
        for i in range(10):  # A to J
            group_letter = chr(ord('A') + i)
            optional_inputs[f"image_{group_letter}_a"] = ("IMAGE", {})
            optional_inputs[f"image_{group_letter}_b"] = ("IMAGE", {})
            optional_inputs[f"image_{group_letter}_c"] = ("IMAGE", {})
            optional_inputs[f"prompt_{i+1}"] = ("STRING", {"forceInput": True})
            optional_inputs[f"batch_count_{i+1}"] = ("INT", {
                "default": 1,
                "min": 1,
                "max": 10,
                "step": 1,
                "display": "number"
            })

        return {
            "required": {
                # === 各模式最大尝试次数（核心控制）===
                "社区版_最大尝试次数": ("INT", {
                    "default": 2,
                    "min": 0,
                    "max": 5,
                    "step": 1,
                    "tooltip": "设为0则跳过该模式。执行顺序：第1位（最优先）"
                }),
                "全能Xinbao_最大尝试次数": ("INT", {
                    "default": 1,
                    "min": 0,
                    "max": 5,
                    "step": 1,
                    "tooltip": "设为0则跳过该模式。执行顺序：第2位"
                }),
                "官方PRO版_最大尝试次数": ("INT", {
                    "default": 1,
                    "min": 0,
                    "max": 5,
                    "step": 1,
                    "tooltip": "设为0则跳过该模式。执行顺序：第3位（最后）"
                }),

                # === API 密钥（命名统一）===
                "runninghub_api_key": ("STRING", {"default": "", "placeholder": "RunningHub API 密钥"}),
                "全能Xinbao_api_key": ("STRING", {"default": "", "placeholder": "全能Xinbao API 密钥"}),

                # === 全局参数（所有模式通用）===
                "image_hosting": (["ImgBB", "阿里云 OSS"], {"default": "ImgBB"}),
                "imgbb_api_key": ("STRING", {"default": "", "placeholder": "ImgBB API 密钥"}),
                "oss_access_key_id": ("STRING", {"default": "", "placeholder": "阿里云 AccessKey ID"}),
                "oss_access_key_secret": ("STRING", {"default": "", "placeholder": "阿里云 AccessKey Secret"}),
                "oss_bucket_name": ("STRING", {"default": "", "placeholder": "OSS Bucket 名称"}),
                "oss_endpoint": ("STRING", {"default": "oss-cn-beijing.aliyuncs.com", "placeholder": "OSS Endpoint"}),
                "resolution": (["1K", "2K", "4K", "8K"], {"default": "1K"}),
                "aspect_ratio": (["1:1", "2:3", "3:2", "3:4", "4:3", "4:5", "5:4", "16:9", "9:16", "21:9", "自动"], {"default": "自动"}),
                "seed": ("INT", {"default": 0, "min": 0, "max": 0xffffffffffffffff}),
                "global_concurrent_tasks": ("INT", {
                    "default": 3,
                    "min": 1,
                    "max": 10,
                    "step": 1,
                    "tooltip": "全局最大并发组数（1～10）"
                }),
                "max_wait_time": ("INT", {
                    "default": 120,
                    "min": 30,
                    "max": 600,
                    "step": 30,
                    "tooltip": "每个子任务最大等待时间（秒），适用于所有API模式"
                }),
            },
            "optional": optional_inputs
        }

    RETURN_TYPES = ("IMAGE",) * 10
    RETURN_NAMES = tuple(f"输出_{i}" for i in range(1, 11))
    FUNCTION = "generate"
    CATEGORY = "影客AI"

    # --- 工具方法 ---
    def tensor_to_pil(self, tensor):
        if tensor.ndim == 4:
            tensor = tensor.squeeze(0)
        i = 255. * tensor.cpu().numpy()
        img = Image.fromarray(np.clip(i, 0, 255).astype(np.uint8))
        return img

    def pil_to_tensor(self, pil_img):
        img_array = np.array(pil_img).astype(np.float32) / 255.0
        return torch.from_numpy(img_array)[None,]

    def upload_to_imgbb(self, pil_img, imgbb_api_key):
        if not imgbb_api_key.strip():
            raise ValueError("请填写 ImgBB API 密钥")
        buf = BytesIO()
        pil_img.save(buf, format="PNG")
        buf.seek(0)
        response = requests.post(
            "https://api.imgbb.com/1/upload",
            data={"key": imgbb_api_key.strip()},
            files={"image": buf.read()},
            timeout=30
        )
        response.raise_for_status()
        result = response.json()
        if result.get("success"):
            return result["data"]["url"]
        else:
            error_msg = result.get("error", {}).get("message", "未知上传错误")
            raise RuntimeError(f"ImgBB 上传失败: {error_msg}")

    def upload_to_aliyun_oss(self, pil_img, access_key_id, access_key_secret, bucket_name, endpoint):
        if not OSS_AVAILABLE:
            raise RuntimeError("未安装 oss2 库，请运行: pip install oss2")
        if not all([access_key_id.strip(), access_key_secret.strip(), bucket_name.strip()]):
            raise ValueError("请填写完整的阿里云 OSS 配置信息")

        timestamp = str(int(time.time() * 1000))
        random_suffix = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=8))
        object_key = f"comfyui_rhart/{timestamp}_{random_suffix}.png"

        auth = oss2.Auth(access_key_id.strip(), access_key_secret.strip())
        bucket = oss2.Bucket(auth, f'https://{endpoint.strip()}', bucket_name.strip())

        buf = BytesIO()
        pil_img.save(buf, format="PNG")
        buf.seek(0)

        try:
            bucket.put_object(object_key, buf.getvalue(), headers={'Content-Type': 'image/png'})
        except Exception as e:
            raise RuntimeError(f"阿里云 OSS 上传失败: {e}")

        return f"https://{bucket_name.strip()}.{endpoint.strip()}/{object_key}"

    def upload_image(self, pil_img, image_hosting, **creds):
        if image_hosting == "ImgBB":
            return self.upload_to_imgbb(pil_img, creds.get("imgbb_api_key", ""))
        elif image_hosting == "阿里云 OSS":
            if not OSS_AVAILABLE:
                raise RuntimeError("请选择 ImgBB，或安装 oss2 库以使用阿里云 OSS")
            return self.upload_to_aliyun_oss(
                pil_img,
                creds.get("oss_access_key_id", ""),
                creds.get("oss_access_key_secret", ""),
                creds.get("oss_bucket_name", ""),
                creds.get("oss_endpoint", "")
            )
        else:
            raise ValueError(f"不支持的图床: {image_hosting}")

    # ====== 全能Xinbao 图像生成 ======
    def process_single_variation_banana(self, group_id, var_id, image_urls, prompt, seed,
                                       banana_api_key, model, resolution, aspect_ratio, max_wait_time):
        base_url = "https://xinbaoapi.dpdns.org"
        headers = {
            "Authorization": f"Bearer {banana_api_key.strip()}",
            "Content-Type": "application/json"
        }

        parts = [{"text": prompt}]
        for url in image_urls[:5]:
            parts.append({
                "inlineData": {
                    "mimeType": "image/jpeg",
                    "data": url
                }
            })

        image_config = {}
        if resolution in ["1K", "2K", "4K", "8K"]:
            api_res = "4K" if resolution == "8K" else resolution
            image_config["imageSize"] = api_res
        if aspect_ratio != "自动":
            image_config["aspectRatio"] = aspect_ratio

        payload = {
            "contents": [{"role": "user", "parts": parts}],
            "generationConfig": {
                "responseModalities": ["IMAGE"],
                "output": "url",
                **({"topP": 0.95} if seed is not None else {}),
                **({"imageConfig": image_config} if image_config else {})
            }
        }

        print(f"[DEBUG] [组 {group_id} 变体 {var_id}] 发送 全能Xinbao 请求 (model=gemini-3-pro-image-preview, timeout=120s)", flush=True)
        resp = requests.post(
            f"{base_url}/v1beta/models/gemini-3-pro-image-preview:generateContent",
            json=payload,
            headers=headers,
            timeout=120
        )
        resp.raise_for_status()
        data = resp.json()

        candidates = data.get("candidates", [])
        if not candidates:
            raise RuntimeError(f"[组 {group_id} 变体 {var_id}] 全能Xinbao 无候选结果")

        parts_out = candidates[0].get("content", {}).get("parts", [])
        output_pil = None
        for part in parts_out:
            inline = part.get("inlineData", {})
            mime_type = inline.get("mimeType", "")
            img_data = inline.get("data", "")
            if mime_type.startswith("image/") and isinstance(img_data, str):
                try:
                    if img_data.startswith("http"):
                        img_resp = requests.get(img_data, timeout=30)
                        img_resp.raise_for_status()
                        output_pil = Image.open(BytesIO(img_resp.content)).convert("RGB")
                    else:
                        image_bytes = base64.b64decode(img_data)
                        output_pil = Image.open(BytesIO(image_bytes)).convert("RGB")
                    break
                except Exception as e:
                    continue

        if output_pil is None:
            raise RuntimeError(f"[组 {group_id} 变体 {var_id}] 全能Xinbao 未返回可解析图片")
        return output_pil

    # ====== RunningHub 方法 ======
    def _get_endpoint_paths(self, mode):
        if mode == "official":
            return "/openapi/v2/rhart-image-n-pro-official/edit"
        else:
            return "/openapi/v2/rhart-image-n-pro/edit"

    def process_single_variation_runninghub(self, group_id, var_id, image_urls, prompt, seed,
                                           api_key, resolution, aspect_ratio, max_wait_time, endpoint_path):
        base_url = "https://www.runninghub.cn"
        headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
        status_headers = {"Content-Type": "application/json"}
        poll_interval = 3
        max_attempts = min(max_wait_time, 600) // poll_interval or 1

        api_resolution = "4K" if resolution == "8K" else resolution
        submit_payload = {"prompt": prompt, "imageUrls": image_urls, "resolution": api_resolution.lower()}
        if aspect_ratio != "自动":
            ar_map = {"1:1":"1:1","2:3":"2:3","3:2":"3:2","3:4":"3:4","4:3":"4:3","4:5":"4:5","5:4":"5:4","16:9":"16:9","9:16":"9:16","21:9":"21:9"}
            submit_payload["aspectRatio"] = ar_map.get(aspect_ratio, "auto")

        submit_resp = requests.post(f"{base_url}{endpoint_path}", json=submit_payload, headers=headers, timeout=30)
        submit_resp.raise_for_status()
        task_id = submit_resp.json().get("taskId")
        if not task_id:
            raise RuntimeError(f"[组 {group_id} 变体 {var_id}] 未返回 taskId")

        status_payload = {"apiKey": api_key, "taskId": task_id}
        for attempt in range(1, max_attempts + 1):
            time.sleep(poll_interval)
            try:
                resp = requests.post(f"{base_url}/task/openapi/status", json=status_payload, headers=status_headers, timeout=30)
                resp.raise_for_status()
                data = resp.json()
                if data.get("code") == 0 and data.get("data") == "SUCCESS":
                    break
                elif data.get("data") == "FAILED":
                    raise RuntimeError("任务失败")
            except:
                pass
        else:
            raise RuntimeError(f"超时（>{max_wait_time}秒）")

        outputs_resp = requests.post(f"{base_url}/task/openapi/outputs", json=status_payload, headers=status_headers, timeout=30)
        outputs_resp.raise_for_status()
        file_url = outputs_resp.json().get("data", [{}])[0].get("fileUrl")
        if not file_url:
            raise RuntimeError("无输出图 URL")

        img_resp = requests.get(file_url, timeout=30)
        img_resp.raise_for_status()
        return Image.open(BytesIO(img_resp.content)).convert("RGB")

    # ====== 核心：多策略尝试引擎（固定顺序）======
    def _build_strategy_from_attempts(self, community_tries, xinbao_tries, official_tries):
        strategy = []
        if community_tries > 0:
            strategy.append({"type": "community", "max_retries": community_tries})
        if xinbao_tries > 0:
            strategy.append({"type": "xinbao", "max_retries": xinbao_tries})
        if official_tries > 0:
            strategy.append({"type": "official", "max_retries": official_tries})
        if not strategy:
            raise ValueError("所有模式的尝试次数均为0，请至少启用一个模式（将某个尝试次数设为 ≥1）")
        return strategy

    def _attempt_with_strategy(self, group_id, var_id, image_urls, prompt,
                              runninghub_api_key, banana_api_key,
                              resolution, aspect_ratio, max_wait_time,
                              strategy):
        total_attempt = 0
        for step in strategy:
            api_type = step["type"]
            max_retries = step["max_retries"]
            for retry in range(max_retries):
                total_attempt += 1
                seed = random.randint(0, 0xffffffff)
                try:
                    if api_type == "community":
                        print(f"[组 {group_id} 变体 {var_id}] 尝试 #{total_attempt} 使用 社区版 (seed={seed})", flush=True)
                        img = self.process_single_variation_runninghub(
                            group_id, var_id, image_urls, prompt, seed,
                            runninghub_api_key,
                            resolution, aspect_ratio, max_wait_time,
                            self._get_endpoint_paths("community")
                        )
                    elif api_type == "official":
                        print(f"[组 {group_id} 变体 {var_id}] 尝试 #{total_attempt} 使用 官方PRO版 (seed={seed})", flush=True)
                        img = self.process_single_variation_runninghub(
                            group_id, var_id, image_urls, prompt, seed,
                            runninghub_api_key,
                            resolution, aspect_ratio, max_wait_time,
                            self._get_endpoint_paths("official")
                        )
                    elif api_type == "xinbao":
                        print(f"[组 {group_id} 变体 {var_id}] 尝试 #{total_attempt} 使用 全能Xinbao (seed={seed})", flush=True)
                        img = self.process_single_variation_banana(
                            group_id, var_id, image_urls, prompt, seed,
                            banana_api_key,
                            "gemini-3-pro-image-preview",
                            resolution, aspect_ratio, max_wait_time
                        )
                    print(f"[组 {group_id} 变体 {var_id}] 成功 ✅", flush=True)
                    return img
                except Exception as e:
                    wait_sec = min(2 ** retry, 10)
                    print(f"⚠️ [组 {group_id} 变体 {var_id}] {api_type} 第 {retry+1} 次失败: {e}", flush=True)
                    if total_attempt < sum(s["max_retries"] for s in strategy):
                        print(f"   → {wait_sec} 秒后重试...", flush=True)
                        time.sleep(wait_sec)
        print(f"❌ [组 {group_id} 变体 {var_id}] 所有 {total_attempt} 次尝试均失败", flush=True)
        return None

    def process_single_group_with_batch(self, group_id, image_tensors, prompt, batch_count,
                                       runninghub_api_key, banana_api_key,
                                       image_hosting, creds,
                                       resolution, aspect_ratio, max_wait_time,
                                       global_max_workers, strategy):
        image_urls = []
        hosting_name = "ImgBB" if image_hosting == "ImgBB" else "阿里云 OSS"
        print(f"[组 {group_id}] 正在上传 {len(image_tensors)} 张参考图到 {hosting_name}...", flush=True)
        for idx, tensor in enumerate(image_tensors[:5], 1):
            pil_img = self.tensor_to_pil(tensor)
            url = self.upload_image(pil_img, image_hosting, **creds)
            image_urls.append(url)
            print(f"[组 {group_id}] 参考图 {idx} 上传成功: {url}", flush=True)
        print(f"[组 {group_id}] 参考图全部上传完成，开始生成 {batch_count} 个变体", flush=True)

        successful_results = []
        with ThreadPoolExecutor(max_workers=min(batch_count, global_max_workers)) as executor:
            futures = [
                executor.submit(
                    self._attempt_with_strategy,
                    group_id, var_index + 1, image_urls, prompt,
                    runninghub_api_key, banana_api_key,
                    resolution, aspect_ratio, max_wait_time,
                    strategy
                )
                for var_index in range(batch_count)
            ]
            for future in futures:
                try:
                    result = future.result()
                    if result is not None:
                        successful_results.append(self.pil_to_tensor(result))
                except:
                    pass

        if successful_results:
            print(f"[组 {group_id}] 成功生成 {len(successful_results)} / {batch_count} 个变体", flush=True)
            return torch.cat(successful_results, dim=0)
        else:
            print(f"[组 {group_id}] 所有变体均失败", flush=True)
            return torch.zeros((1, 64, 64, 3), dtype=torch.float32)

    def generate(self,
                 社区版_最大尝试次数,
                 全能Xinbao_最大尝试次数,
                 官方PRO版_最大尝试次数,
                 runninghub_api_key, 全能Xinbao_api_key,
                 image_hosting,
                 imgbb_api_key,
                 oss_access_key_id, oss_access_key_secret, oss_bucket_name, oss_endpoint,
                 resolution, aspect_ratio, seed, global_concurrent_tasks, max_wait_time, **kwargs):

        # === 构建策略：固定顺序（社区 → 全能Xinbao → 官方）===
        strategy = self._build_strategy_from_attempts(
            int(社区版_最大尝试次数),
            int(全能Xinbao_最大尝试次数),
            int(官方PRO版_最大尝试次数)
        )

        # === 密钥校验 ===
        need_runninghub = any(step["type"] in ["community", "official"] for step in strategy)
        need_xinbao = any(step["type"] == "xinbao" for step in strategy)

        if need_runninghub and not runninghub_api_key.strip():
            raise ValueError("当前策略需要 RunningHub API 密钥，请填写")
        if need_xinbao and not 全能Xinbao_api_key.strip():
            raise ValueError("当前策略包含「全能Xinbao」，请填写其 API 密钥")

        # === 图床校验 ===
        creds = {
            "imgbb_api_key": imgbb_api_key,
            "oss_access_key_id": oss_access_key_id,
            "oss_access_key_secret": oss_access_key_secret,
            "oss_bucket_name": oss_bucket_name,
            "oss_endpoint": oss_endpoint,
        }

        if image_hosting == "ImgBB":
            if not imgbb_api_key.strip():
                raise ValueError("图床选择 ImgBB 时，请填写 API 密钥")
        elif image_hosting == "阿里云 OSS":
            if not OSS_AVAILABLE:
                raise ValueError("请安装 oss2: pip install oss2")
            if not all([oss_access_key_id.strip(), oss_access_key_secret.strip(), oss_bucket_name.strip()]):
                raise ValueError("请填写完整的阿里云 OSS 配置")

        global_concurrent_tasks = min(max(1, int(global_concurrent_tasks)), 10)
        max_wait_time = min(max(30, int(max_wait_time)), 600)

        placeholder = torch.zeros((1, 64, 64, 3), dtype=torch.float32)
        results = [placeholder] * 10

        tasks = []
        for i in range(1, 11):
            prompt_val = kwargs.get(f"prompt_{i}", "").strip()
            batch_count = int(kwargs.get(f"batch_count_{i}", 1))
            batch_count = max(1, min(10, batch_count))

            images_i = []
            group_letter = chr(ord('A') + i - 1)
            for suffix in ['a', 'b', 'c']:
                img = kwargs.get(f"image_{group_letter}_{suffix}")
                if img is not None and img.shape[0] > 0:
                    images_i.append(img)

            if images_i and prompt_val:
                combined = torch.cat(images_i, dim=0)
                tasks.append((i, combined, prompt_val, batch_count))
            else:
                tasks.append(None)

        if not any(tasks):
            raise ValueError("至少需要一组有效的（提示词 + 至少1张参考图）")

        with ThreadPoolExecutor(max_workers=global_concurrent_tasks) as executor:
            futures = {}
            for idx, task in enumerate(tasks):
                if task is None:
                    continue
                group_id, images, prompt, batch_count = task
                future = executor.submit(
                    self.process_single_group_with_batch,
                    group_id, images, prompt, batch_count,
                    runninghub_api_key, 全能Xinbao_api_key,
                    image_hosting, creds,
                    resolution, aspect_ratio, max_wait_time,
                    global_concurrent_tasks,
                    strategy
                )
                futures[future] = idx

            for future in as_completed(futures):
                out_idx = futures[future]
                try:
                    results[out_idx] = future.result()
                except Exception as e:
                    print(f"⚠️ 组 {out_idx + 1} 整体失败: {e}", flush=True)

        return tuple(results)


NODE_CLASS_MAPPINGS = {
    "RunningHub_Rhart_ImageToImageBatch10": RunningHubRhartImageToImageBatch10
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "RunningHub_Rhart_ImageToImageBatch10": "YK-影客AI-RUNHUB全能图片PRO（社区/全能Xinbao/官方混合）"
}